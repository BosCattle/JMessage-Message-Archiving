/*
 * JDBCMessageArchiveRepository.java
 *
 * Tigase Jabber/XMPP Server
 * Copyright (C) 2004-2014 "Tigase, Inc." <office@tigase.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. Look for COPYING file in the top folder.
 * If not, see http://www.gnu.org/licenses/.
 *
 */
package tigase.archive.db;

//~--- non-JDK imports --------------------------------------------------------

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Date;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.logging.Level;
import java.util.logging.Logger;
import tigase.archive.RSM;
import tigase.db.DBInitException;
import tigase.db.DataRepository;
import static tigase.db.DataRepository.dbTypes.derby;
import tigase.db.Repository;
import tigase.db.RepositoryFactory;
import tigase.db.TigaseDBException;
import tigase.xml.DomBuilderHandler;
import tigase.xml.Element;
import tigase.xml.SimpleParser;
import tigase.xml.SingletonFactory;
import tigase.xmpp.BareJID;

/**
 * Class description
 *
 *
 * @version        Enter version here..., 13/02/16
 * @author         Enter your name here...
 */
@Repository.Meta( supportedUris = { "jdbc:[^:]+:.*" } )
public class JDBCMessageArchiveRepository extends AbstractMessageArchiveRepository {
	private static final String JIDS_ID  = "jid_id";
	private static final String JIDS_JID = "jid";

	// jids table
	private static final String JIDS_TABLE = "tig_ma_jids";
	private static final Logger log        =
		Logger.getLogger(JDBCMessageArchiveRepository.class.getCanonicalName());
	private static final long LONG_NULL              = 0;
	private static final long MILIS_PER_DAY          = 24 * 60 * 60 * 1000;
	
	private static final String[] MSG_BODY_PATH = { "message", "body" };

	private static final String MSGS_BUDDY_ID  = "buddy_id";
	private static final String MSGS_BODY      = "body";
	private static final String MSGS_DIRECTION = "direction";
	private static final String MSGS_MSG       = "msg";
	private static final String MSGS_OWNER_ID  = "owner_id";

//+ "create unique index " + JIDS_TABLE + "_" + JIDS_JID + " on "
//+ JIDS_TABLE + " ( " + JIDS_JID + "(765));";
	// messages table
	private static final String MSGS_TABLE        = "tig_ma_msgs";
	private static final String MSGS_TIMESTAMP    = "ts";
	private static final String MSGS_TYPE         = "type";
	private static final SimpleParser parser      = SingletonFactory.getParserInstance();
	private static final String GET_JID_IDS_QUERY = "select " + JIDS_JID + ", " + JIDS_ID +
																									" from " + JIDS_TABLE + " where " +
																									JIDS_JID + " = ?" + " or " + JIDS_JID +
																									" = ?";
	private static final String GET_JID_ID_QUERY = "select " + JIDS_JID + ", " + JIDS_ID +
																								 " from " + JIDS_TABLE + " where " +
																								 JIDS_JID + " = ?";
	private static final String ADD_JID_QUERY = "insert into " + JIDS_TABLE + " (" +
																							JIDS_JID + ") values (?)";
	private static final String DERBY_CREATE_JIDS = "create table " + JIDS_TABLE + " ( "
																									+ JIDS_ID + " bigint generated by default as identity not null, " + JIDS_JID
																									+ " varchar(2049), primary key ( " + JIDS_ID + " ));"
																									+ "create unique index " + JIDS_TABLE + "_" + JIDS_JID + " on " + JIDS_TABLE
																									+ " (" + JIDS_JID + ");";
	private static final String PGSQL_CREATE_JIDS = "create table " + JIDS_TABLE + " ( "
																									+ JIDS_ID + " bigserial, " + JIDS_JID
																									+ " varchar(2049), primary key ("
																									+ JIDS_ID + ")); "
																									+ "create unique index " + JIDS_TABLE
																									+ "_" + JIDS_JID + " on " + JIDS_TABLE
																									+ " ( " + JIDS_JID + ");";
	private static final String SQLSERVER_CREATE_JIDS = "create table " + JIDS_TABLE + " ( "
																									+ JIDS_ID + " bigint identity(1,1), " + JIDS_JID
																									+ " nvarchar(2049),"
																									+ JIDS_JID + "_fragment as left (" + JIDS_JID + ", 765),"
																									+ "primary key (" + JIDS_ID + ")); "
																									+ "create unique index " + JIDS_TABLE
																									+ "_" + JIDS_JID + " on " + JIDS_TABLE
																									+ " ( " + JIDS_JID + "_fragment " + ");";
	private static final String MYSQL_CREATE_JIDS =
															"create table " + JIDS_TABLE + " ( " + JIDS_ID
															+ " bigint unsigned NOT NULL auto_increment, " + JIDS_JID
															+ " varchar(2049), primary key (" + JIDS_ID + ")); ";
//	private static final String GET_MESSAGES = "select " + MSGS_MSG + " from " +
//																						 MSGS_TABLE + " where " + MSGS_OWNER_ID +
//																						 " = ? and " + MSGS_BUDDY_ID + " = ?" +
//																						 " and date(" + MSGS_TIMESTAMP +
//																						 ") = date(?)" + " order by " +
//																						 MSGS_TIMESTAMP + " limit ? offset ?";
//	private static final String DERBY_GET_MESSAGES = "select " + MSGS_MSG + " from " +
//																						 MSGS_TABLE + " where " + MSGS_OWNER_ID +
//																						 " = ? and " + MSGS_BUDDY_ID + " = ?" +
//																						 " and date(" + MSGS_TIMESTAMP +
//																						 ") = ?" + " order by " +
//																						 MSGS_TIMESTAMP + " offset ? rows fetch next ? rows only";
	private static final String GENERIC_GET_MESSAGES = "select " + MSGS_MSG + ", " + MSGS_TIMESTAMP + "," + MSGS_DIRECTION 
			+ " from " + MSGS_TABLE + " where " + MSGS_OWNER_ID + " = ? and " 
			+ MSGS_BUDDY_ID + " = ? and " + MSGS_TIMESTAMP + " >= ?";
	private static final String MSSQL2008_GET_MESSAGES = "select x." + MSGS_MSG + ", x." + MSGS_TIMESTAMP + ", x." + MSGS_DIRECTION + " FROM ( "
			+ "select " + MSGS_MSG + ", " + MSGS_TIMESTAMP + "," + MSGS_DIRECTION + ", ROW_NUMBER() over (order by " + MSGS_TIMESTAMP + ") as rn"
			+ " from " + MSGS_TABLE + " where " + MSGS_OWNER_ID + " = ? and " 
			+ MSGS_BUDDY_ID + " = ? and " + MSGS_TIMESTAMP + " >= ?) x";
	private static final String GENERIC_GET_MESSAGES_END = "select " + MSGS_MSG + ", " + MSGS_TIMESTAMP + "," + MSGS_DIRECTION 
			+ " from " + MSGS_TABLE + " where " + MSGS_OWNER_ID + " = ? and " 
			+ MSGS_BUDDY_ID + " = ? and " + MSGS_TIMESTAMP + " >= ? and " + MSGS_TIMESTAMP + " <= ?";
	private static final String MSSQL2008_GET_MESSAGES_END = "select x." + MSGS_MSG + ", x." + MSGS_TIMESTAMP + ", x." + MSGS_DIRECTION + " FROM ( "
			+ "select " + MSGS_MSG + ", " + MSGS_TIMESTAMP + "," + MSGS_DIRECTION + ", ROW_NUMBER() over (order by " + MSGS_TIMESTAMP + ") as rn"
			+ " from " + MSGS_TABLE + " where " + MSGS_OWNER_ID + " = ? and " 
			+ MSGS_BUDDY_ID + " = ? and " + MSGS_TIMESTAMP + " >= ? and " + MSGS_TIMESTAMP + " <= ?) x";
	private static final String GENERIC_GET_MESSAGES_COUNT = "select count(" + MSGS_TIMESTAMP + ") from " + MSGS_TABLE + " where " + MSGS_OWNER_ID 
			+ " = ? and " + MSGS_BUDDY_ID + " = ? and " + MSGS_TIMESTAMP + " >= ?";
	private static final String GENERIC_GET_MESSAGES_END_COUNT = "select count(" + MSGS_TIMESTAMP + ") from " + MSGS_TABLE + " where " 
			+ MSGS_OWNER_ID + " = ? and " + MSGS_BUDDY_ID + " = ? and " + MSGS_TIMESTAMP + " >= ? and " + MSGS_TIMESTAMP + " <= ?";
	private static final String GENERIC_GET_MESSAGES_ORDER_BY = " order by " + MSGS_TIMESTAMP;
//	private static final String GET_COLLECTIONS = "select distinct date(" +
//																								MSGS_TIMESTAMP + ")" + " from " +
//																								MSGS_TABLE + " where " + MSGS_OWNER_ID +
//																								" = ?" + " and " + MSGS_BUDDY_ID +
//																								" = ? and " + MSGS_TIMESTAMP + " <= ?" +
//																								" and " + MSGS_TIMESTAMP + " >= ?" +
//																								" order by date(" + MSGS_TIMESTAMP + ")";
	private static final String GENERIC_GET_COLLECTIONS_SELECT = "select min(m." + MSGS_TIMESTAMP + ") as ts, j." + JIDS_JID + " from " + MSGS_TABLE + " m "
			+ "inner join " + JIDS_TABLE + " j on m." + MSGS_BUDDY_ID + " = j." + JIDS_ID + " where m." + MSGS_OWNER_ID + " = ? ";
	private static final String MSSQL2008_GET_COLLECTIONS_SELECT = "select x." + MSGS_TIMESTAMP + ", x." + JIDS_JID + " from ( "
			+ "select min(m." + MSGS_TIMESTAMP + ") as " + MSGS_TIMESTAMP + ", j." + JIDS_JID + ", ROW_NUMBER() over (order by min(m." + MSGS_TIMESTAMP + "), j." + JIDS_JID + ") as rn from " + MSGS_TABLE + " m "
			+ "inner join " + JIDS_TABLE + " j on m." + MSGS_BUDDY_ID + " = j." + JIDS_ID + " where m." + MSGS_OWNER_ID + " = ? ";
	private static final String GENERIC_GET_COLLECTIONS_SELECT_GROUP = "group by date(m." + MSGS_TIMESTAMP + "), m." + MSGS_BUDDY_ID + ", j." + JIDS_JID;
	// here we have also query for MSSQL2005 but we have 2014 so I suppose it would not be used but I will leave it here for now
	//private static final String MSSQL2005_GET_COLLECTIONS_SELECT_GROUP = "group by cast(CONVERT(char(20), m." + MSGS_TIMESTAMP + ", 112) as datetime), m." + MSGS_BUDDY_ID + ", j." + JIDS_JID;
	private static final String MSSQL2008_GET_COLLECTIONS_SELECT_GROUP = "group by cast(m." + MSGS_TIMESTAMP + " as date), m." + MSGS_BUDDY_ID + ", j." + JIDS_JID + ") x ";
	private static final String GENERIC_GET_COLLECTIONS_SELECT_ORDER = " order by min(m." + MSGS_TIMESTAMP + "), j." + JIDS_JID;
	private static final String MSSQL2008_GET_COLLECTIONS_SELECT_ORDER = " order by x." + MSGS_TIMESTAMP + ", x." + JIDS_JID;
	private static final String GENERIC_GET_COLLECTIONS_COUNT = "select count(1) from (select min(m." + MSGS_TIMESTAMP + ") as " + MSGS_TIMESTAMP + ", m." + MSGS_BUDDY_ID + " from " 
			+ MSGS_TABLE + " m where m." + MSGS_OWNER_ID + " = ? ";
	private static final String GENERIC_GET_COLLECTIONS_COUNT_GROUP = "group by date(m." + MSGS_TIMESTAMP + "), m." + MSGS_BUDDY_ID + ") x";
	// here we have also query for MSSQL2005 but we have 2014 so I suppose it would not be used but I will leave it here for now
	///private static final String MSSQL2005_GET_COLLECTIONS_COUNT_GROUP = "group by cast(CONVERT(char(20), m." + MSGS_TIMESTAMP + ", 112) as datetime), m." + MSGS_BUDDY_ID + ") x";
	private static final String MSSQL2008_GET_COLLECTIONS_COUNT_GROUP = "group by cast(m." + MSGS_TIMESTAMP + " as date), m." + MSGS_BUDDY_ID + ") x";
	private static final String GENERIC_LIMIT = " limit ? offset ?";					// limit, offset
	private static final String DERBY_LIMIT = " offset ? rows fetch next ? rows only";	// offset, limit
	private static final String MSSQL2008_LIMIT = " where x.rn > ? and x.rn < ?";				// offset, limit + offset
	private static final String[][] GET_COLLECTIONS_WHERES = { 
			{ "FROM", "and m." + MSGS_TIMESTAMP + " >= ? " },
			{ "TO", "and m." + MSGS_TIMESTAMP + " <= ? " },
			{ "WITH", "and m." + MSGS_BUDDY_ID + " = ? " }
	};
	private static final String[] GET_COLLECTIONS_COMBINATIONS = {
		"FROM", "FROM_TO", "FROM_TO_WITH", "FROM_WITH",
		"TO", "TO_WITH", "WITH"
	};
//	private static final String GET_COLLECTIONS_PGSQL = "select min(ts),j.jid from tig_ma_msgs m inner join tig_ma_jids j on m.buddy_id = j.jid_id "
//			+ "where owner_id = 4 and ts >= '2013-11-13' "
//			+ "group by floor(EXTRACT(EPOCH FROM (ts - cast('2013-11-12T22:00:00-0000' as timestamp with time zone)))/(60*60*24)), buddy_id, j.jid;"
//	private static final String GET_COLLECTIONS_MYSQL = "select min(ts), j.jid from tig_ma_msgs m "
//			+ "inner join tig_ma_jids j on m.buddy_id = j.jid_id where owner_id = 4 group by datediff(ts,'2013-11-01T00:00:00'), buddy_id"
	private static final String ADD_MESSAGE = "insert into " + MSGS_TABLE + " (" +
																						MSGS_OWNER_ID + ", " + MSGS_BUDDY_ID + ", " +
																						MSGS_TIMESTAMP + ", " + MSGS_DIRECTION +
																						", " + MSGS_TYPE + ", " + MSGS_BODY + ", " + MSGS_MSG + ")" +
																						" values (?, ?, ?, ?, ?, ?, ?)";
	private static final String REMOVE_MSGS = "delete from " + MSGS_TABLE + " where " +
																						MSGS_OWNER_ID + " = ? and " + MSGS_BUDDY_ID +
																						" = ?" + " and " + MSGS_TIMESTAMP +
																						" <= ? and " + MSGS_TIMESTAMP + " >= ?";
	private static final String DERBY_CREATE_MSGS = "create table " + MSGS_TABLE + " ("
																									+ MSGS_OWNER_ID + " bigint references " + JIDS_TABLE + "(" + JIDS_ID + "),"
																									+ MSGS_BUDDY_ID + " bigint references " + JIDS_TABLE + "(" + JIDS_ID + "),"
																									+ MSGS_TIMESTAMP + " timestamp, "
																									+ MSGS_DIRECTION + " smallint, "
																									+ MSGS_TYPE + " varchar(10), "
																									+ MSGS_BODY + " varchar(32672), "
																									+ MSGS_MSG + " varchar(32672));"
																									+ "create index " + MSGS_TABLE + "_" + MSGS_OWNER_ID + "_index on " + MSGS_TABLE
																									+ " (" + MSGS_OWNER_ID + ");"
																									+ "create index " + MSGS_TABLE + "_" + MSGS_OWNER_ID + "_" + MSGS_BUDDY_ID
																									+ "_index on " + MSGS_TABLE + " (" + MSGS_OWNER_ID + ", " + MSGS_BUDDY_ID + ");"
																									+ "create index " + MSGS_TABLE + "_" + MSGS_OWNER_ID + "_" + MSGS_TIMESTAMP + "_"
																									+ MSGS_BUDDY_ID + "_index on " + MSGS_TABLE + " (" + MSGS_OWNER_ID + ", "
																									+ MSGS_TIMESTAMP + ", " + MSGS_BUDDY_ID + ");";
	private static final String PGSQL_CREATE_MSGS = "create table " + MSGS_TABLE + " (" +
																									MSGS_OWNER_ID + " bigint, " +
																									MSGS_BUDDY_ID + " bigint, " +
																									MSGS_TIMESTAMP + " timestamp, " +
																									MSGS_DIRECTION + " smallint, " +
																									MSGS_TYPE + " varchar(10), " +
																									MSGS_BODY + " text, " +
																									MSGS_MSG + " text," +
																									" foreign key (" + MSGS_BUDDY_ID +
																									") references " + JIDS_TABLE + " (" +
																									JIDS_ID + ")," + " foreign key (" +
																									MSGS_OWNER_ID + ") references " +
																									JIDS_TABLE + " (" + JIDS_ID + ") ); " +
																									"create index " + MSGS_TABLE + "_" +
																									MSGS_OWNER_ID + "_index on " +
																									MSGS_TABLE + " ( " + MSGS_OWNER_ID +
																									"); " + "create index " + MSGS_TABLE +
																									"_" + MSGS_OWNER_ID + "_" +
																									MSGS_BUDDY_ID + "_index on " +
																									MSGS_TABLE + " ( " + MSGS_OWNER_ID +
																									", " + MSGS_BUDDY_ID + "); " +
																									"create index " + MSGS_TABLE + "_" +
																									MSGS_OWNER_ID + "_" + MSGS_TIMESTAMP +
																									"_" + MSGS_BUDDY_ID + "_index on " +
																									MSGS_TABLE + " ( " + MSGS_OWNER_ID +
																									", " + MSGS_TIMESTAMP + ", " + 
																									MSGS_BUDDY_ID + "); ";
	private static final String SQLSERVER_CREATE_MSGS = "create table " + MSGS_TABLE + " (" +
																									MSGS_OWNER_ID + " bigint, " +
																									MSGS_BUDDY_ID + " bigint, " +
																									MSGS_TIMESTAMP + " datetime, " +
																									MSGS_DIRECTION + " smallint, " +
																									MSGS_TYPE + " nvarchar(10)," +
																									MSGS_BODY + " ntext, " +
																									MSGS_MSG + " ntext," +
																									" foreign key (" + MSGS_BUDDY_ID +
																									") references " + JIDS_TABLE + " (" +
																									JIDS_ID + ")," + " foreign key (" +
																									MSGS_OWNER_ID + ") references " +
																									JIDS_TABLE + " (" + JIDS_ID + ") ); " +
																									"create index " + MSGS_TABLE + "_" +
																									MSGS_OWNER_ID + "_index on " +
																									MSGS_TABLE + " ( " + MSGS_OWNER_ID +
																									"); " + "create index " + MSGS_TABLE +
																									"_" + MSGS_OWNER_ID + "_" +
																									MSGS_BUDDY_ID + "_index on " +
																									MSGS_TABLE + " ( " + MSGS_OWNER_ID +
																									", " + MSGS_BUDDY_ID + "); " +
																									"create index " + MSGS_TABLE + "_" +
																									MSGS_OWNER_ID + "_" + MSGS_TIMESTAMP +
																									"_" + MSGS_BUDDY_ID + "_index on " +
																									MSGS_TABLE + " ( " + MSGS_OWNER_ID +
																									", " + MSGS_TIMESTAMP + ", " +
																									MSGS_BUDDY_ID + "); ";
	private static final String MYSQL_CREATE_MSGS = "create table " + MSGS_TABLE + " (" +
																									MSGS_OWNER_ID + " bigint unsigned, " +
																									MSGS_BUDDY_ID + " bigint unsigned, " +
																									MSGS_TIMESTAMP + " timestamp, " +
																									MSGS_DIRECTION + " smallint, " +
																									MSGS_TYPE + " varchar(10)," +
																									MSGS_BODY + " text, " + 
																									MSGS_MSG + " text," +
																									" foreign key (" + MSGS_BUDDY_ID +
																									") references " + JIDS_TABLE + " (" +
																									JIDS_ID + ")," + " foreign key (" +
																									MSGS_OWNER_ID + ") references " +
																									JIDS_TABLE + " (" + JIDS_ID + "), " +
																									"key (" + MSGS_OWNER_ID + "), " + 
																									"key (" + MSGS_OWNER_ID + ", " + 
																									MSGS_BUDDY_ID + "), key (" + 
																									MSGS_OWNER_ID + ", " + MSGS_TIMESTAMP + 
																									", " + MSGS_BUDDY_ID + "));";

	private static final String STORE_PLAINTEXT_BODY_KEY = "store-plaintext-body";
	
	//~--- fields ---------------------------------------------------------------

	private DataRepository data_repo = null;
	private boolean storePlaintextBody = true;

	//~--- methods --------------------------------------------------------------

	/**
	 * Method description
	 *
	 *
	 * @param conn_str
	 * @param params
	 *
	 * @throws SQLException
	 */
	@Override
	public void initRepository(String conn_str, Map<String, String> params)
					throws DBInitException {
		try {
			data_repo = RepositoryFactory.getDataRepository( null, conn_str, params );
			if (params.containsKey(STORE_PLAINTEXT_BODY_KEY)) {
				storePlaintextBody = Boolean.parseBoolean(params.get(STORE_PLAINTEXT_BODY_KEY));
			} else {
				storePlaintextBody = true;
			}

			// create tables if not exist
			switch ( data_repo.getDatabaseType() ) {
				case mysql:
					data_repo.checkTable( JIDS_TABLE, MYSQL_CREATE_JIDS );
					data_repo.checkTable( MSGS_TABLE, MYSQL_CREATE_MSGS );
					break;
				case derby:
					data_repo.checkTable( JIDS_TABLE, DERBY_CREATE_JIDS );
					data_repo.checkTable( MSGS_TABLE, DERBY_CREATE_MSGS );
					break;
				case postgresql:
					data_repo.checkTable( JIDS_TABLE, PGSQL_CREATE_JIDS );
					data_repo.checkTable( MSGS_TABLE, PGSQL_CREATE_MSGS );
					break;
				case jtds:
				case sqlserver:
					data_repo.checkTable( JIDS_TABLE, SQLSERVER_CREATE_JIDS );
					data_repo.checkTable( MSGS_TABLE, SQLSERVER_CREATE_MSGS );
					break;
			}
			
			checkDB();
			
			data_repo.initPreparedStatement(ADD_JID_QUERY, ADD_JID_QUERY);
			data_repo.initPreparedStatement(GET_JID_ID_QUERY, GET_JID_ID_QUERY);
			data_repo.initPreparedStatement(GET_JID_IDS_QUERY, GET_JID_IDS_QUERY);

			data_repo.initPreparedStatement(ADD_MESSAGE, ADD_MESSAGE);
			//data_repo.initPreparedStatement(GET_COLLECTIONS, GET_COLLECTIONS);
			
			for (String combination : GET_COLLECTIONS_COMBINATIONS) {
				String[] whereParts = combination.split("_");
				String select = null;//GET_COLLECTIONS_SELECT;
				String count = GENERIC_GET_COLLECTIONS_COUNT;
				switch ( data_repo.getDatabaseType() ) {
					case sqlserver:
						select = MSSQL2008_GET_COLLECTIONS_SELECT;
						break;
					default:
						select = GENERIC_GET_COLLECTIONS_SELECT;
				}
				for (String part : whereParts) {
					for (String[] where : GET_COLLECTIONS_WHERES) {
						if (!part.equals(where[0]))
							continue;
						
						select += where[1];
						count += where[1];
					}
				}
				
				switch ( data_repo.getDatabaseType() ) {
					case sqlserver:
						select += MSSQL2008_GET_COLLECTIONS_SELECT_GROUP;
						count += MSSQL2008_GET_COLLECTIONS_COUNT_GROUP;
						break;
					default:
						select += GENERIC_GET_COLLECTIONS_SELECT_GROUP + GENERIC_GET_COLLECTIONS_SELECT_ORDER;
						count += GENERIC_GET_COLLECTIONS_COUNT_GROUP;
						break;
				}
				
				switch ( data_repo.getDatabaseType() ) {
					case derby:
						select += DERBY_LIMIT;
						break;
					case sqlserver:
						select += MSSQL2008_LIMIT + MSSQL2008_GET_COLLECTIONS_SELECT_ORDER;
						break;
					default:
						select += GENERIC_LIMIT;
						break;
				}
				data_repo.initPreparedStatement("GET_COLLECTIONS_" + combination + "_SELECT", select);
				data_repo.initPreparedStatement("GET_COLLECTIONS_" + combination + "_COUNT", count);
			}
			
			switch ( data_repo.getDatabaseType() ) {
				case derby:
					data_repo.initPreparedStatement( GENERIC_GET_MESSAGES, GENERIC_GET_MESSAGES + GENERIC_GET_MESSAGES_ORDER_BY + DERBY_LIMIT );
					data_repo.initPreparedStatement( GENERIC_GET_MESSAGES_END, GENERIC_GET_MESSAGES_END + GENERIC_GET_MESSAGES_ORDER_BY + DERBY_LIMIT);
					break;
				case sqlserver:
					data_repo.initPreparedStatement( GENERIC_GET_MESSAGES, MSSQL2008_GET_MESSAGES + MSSQL2008_LIMIT + GENERIC_GET_MESSAGES_ORDER_BY );
					data_repo.initPreparedStatement( GENERIC_GET_MESSAGES_END, MSSQL2008_GET_MESSAGES_END + MSSQL2008_LIMIT + GENERIC_GET_MESSAGES_ORDER_BY);
					break;
				default:
					data_repo.initPreparedStatement( GENERIC_GET_MESSAGES, GENERIC_GET_MESSAGES + GENERIC_GET_MESSAGES_ORDER_BY + GENERIC_LIMIT );
					data_repo.initPreparedStatement( GENERIC_GET_MESSAGES_END, GENERIC_GET_MESSAGES_END + GENERIC_GET_MESSAGES_ORDER_BY + GENERIC_LIMIT );
					break;
			}
			data_repo.initPreparedStatement(GENERIC_GET_MESSAGES_COUNT, GENERIC_GET_MESSAGES_COUNT);
			data_repo.initPreparedStatement(GENERIC_GET_MESSAGES_END_COUNT, GENERIC_GET_MESSAGES_END_COUNT);
			data_repo.initPreparedStatement(REMOVE_MSGS, REMOVE_MSGS);
		} catch (Exception ex) {
			log.log(Level.WARNING, "MessageArchiveDB initialization exception", ex);
		}
	}

	@Override
	public void destroy() {
		// here we use cached instance of repository pool cached by RepositoryFactory
		// so we should not close it
	}
	
	private void checkDB() {
		Statement stmt = null;
		try {
			try {
				stmt = data_repo.createStatement(null);
				stmt.executeQuery("select " + MSGS_BODY + " from " + MSGS_TABLE + " where " + MSGS_OWNER_ID + " = 0");
			} catch (SQLException ex) {
				// if this happens then we have issue with old database schema and missing body columns in MSGS_TABLE
				String alterTable = null;
				switch (data_repo.getDatabaseType()) {
					case derby:
						alterTable = "alter table " + MSGS_TABLE + " add " + MSGS_BODY + " varchar(32672)";
						break;
					case mysql:
						alterTable = "alter table " + MSGS_TABLE + " add " + MSGS_BODY + " text";
						break;
					case postgresql:
						alterTable = "alter table " + MSGS_TABLE + " add " + MSGS_BODY + " text";
						break;
					case jtds:
					case sqlserver:
						alterTable = "alter table " + MSGS_TABLE + " add " + MSGS_BODY + " ntext";
						break;
				}
				try {
					stmt.execute(alterTable);
				} catch (SQLException ex1) {
					log.log(Level.SEVERE, "could not alter table " + MSGS_TABLE + " to add missing column by SQL:\n" + alterTable, ex1);
				}
			}
		} finally {
			data_repo.release(stmt, null);
		}
	}
	
	/**
	 * Method description
	 *
	 *
	 * @param owner
	 * @param buddy
	 * @param direction
	 * @param timestamp
	 * @param msg
	 */
	@Override
	public void archiveMessage(BareJID owner, BareJID buddy, Direction direction, Date timestamp, Element msg) {
		try {
			String owner_str         = owner.toString();
			String buddy_str         = buddy.toString();
			long[] jids_ids          = getJidsIds(owner_str, buddy_str);
			long owner_id            = (jids_ids[0] != LONG_NULL)
																 ? jids_ids[0]
																 : addJidId(owner_str);
			long buddy_id            = (jids_ids[1] != LONG_NULL)
																 ? jids_ids[1]
																 : addJidId(buddy_str);
			java.sql.Timestamp mtime = new java.sql.Timestamp(timestamp.getTime());
			msg.addAttribute("time", String.valueOf(mtime.getTime()));

			String type                      = msg.getAttributeStaticStr("type");
			String msgStr                    = msg.toString();
			String body                      = storePlaintextBody ? msg.getChildCData(MSG_BODY_PATH) : null;
			PreparedStatement add_message_st = data_repo.getPreparedStatement(owner,
																					 ADD_MESSAGE);

			synchronized (add_message_st) {
				add_message_st.setLong(1, owner_id);
				add_message_st.setLong(2, buddy_id);
				add_message_st.setTimestamp(3, mtime);
				add_message_st.setShort(4, direction.getValue());
				add_message_st.setString(5, type);
				add_message_st.setString(6, body);
				add_message_st.setString(7, msgStr);
				add_message_st.executeUpdate();
			}
		} catch (SQLException ex) {
			log.log(Level.WARNING, "Problem adding new entry to DB: {0}", msg);
		} finally {

//    data_repo.release(null, rs);
		}
	}

	//~--- get methods ----------------------------------------------------------

	/**
	 * Method description
	 *
	 *
	 * @param owner
	 * @param withJid
	 * @param start
	 * @param end
	 * @param rsm
	 *
	 * @return
	 * @throws tigase.db.TigaseDBException
	 */
	@Override
	public List<Element> getCollections(BareJID owner, String withJid, Date start,
					Date end, RSM rsm)
					 throws TigaseDBException {
		try {
			long[] jids_ids = withJid == null ? getJidsIds(owner.toString()) : getJidsIds(owner.toString(), withJid);

			Long buddyId = jids_ids.length > 1 ? jids_ids[1] : null;
			java.sql.Timestamp start_ = start != null ? new java.sql.Timestamp(start.getTime()) : null;
			java.sql.Timestamp end_ = end != null ? new java.sql.Timestamp(end.getTime()) : null;

			StringBuilder query = new StringBuilder(20);
			if (start_ != null) {
				query.append("FROM");
			}
			if (end_ != null) {
				if (query.length() > 0) {
					query.append("_");
				}
				query.append("TO");
			}
			if (buddyId != null) {
				if (query.length() > 0) {
					query.append("_");
				}
				query.append("WITH");
			} else {
				// not supported
			}
			String queryStr = query.toString();

			Integer count = getCollectionsCount(owner, jids_ids[0], buddyId, start_, end_, queryStr);
			int index = rsm.getIndex() == null ? 0 : rsm.getIndex();
			int limit = rsm.getMax();
			if (rsm.getAfter() != null) {
				int after = Integer.parseInt(rsm.getAfter());
				// it is ok, if we go out of range we will return empty result
				index = after + 1;
			} else if (rsm.getBefore() != null) {
				int before = Integer.parseInt(rsm.getBefore());
				index = before - rsm.getMax();
			// if we go out of range we need to set index to 0 and reduce limit
				// to return proper results
				if (index < 0) {
					index = 0;
					limit = before;
				}
			} else if (rsm.hasBefore()) {
				index = count - rsm.getMax();
				if (index < 0) {
					index = 0;
				}
			}

			List<Element> results = getCollections(owner, jids_ids[0], buddyId, start_, end_, index, limit, queryStr);

			rsm.setResults(count, index);
			if (!results.isEmpty()) {
				rsm.setFirst(String.valueOf(index));
				rsm.setLast(String.valueOf(index + (results.size() - 1)));
			}

			return results;
		} catch (SQLException ex) {
			throw new TigaseDBException("Cound not retrieve collections", ex);
		}		
	}

	/**
	 * Method description
	 *
	 *
	 * @param owner
	 * @param withJid
	 * @param start
	 * @param end
	 * @param rsm
	 *
	 * @return
	 * @throws tigase.db.TigaseDBException
	 */
	@Override
	public List<Element> getItems(BareJID owner, String withJid, Date start, Date end, RSM rsm)
					 throws TigaseDBException {
		try {
			long[] jids_ids = getJidsIds(owner.toString(), withJid);

			Timestamp startTimestamp = new Timestamp(start.getTime());
			Timestamp endTimestamp = end != null ? new Timestamp(end.getTime()) : null;

			int count = getItemsCount(owner, jids_ids[0], jids_ids[1], startTimestamp, endTimestamp);
			int index = rsm.getIndex() == null ? 0 : rsm.getIndex();
			int limit = rsm.getMax();
			if (rsm.getAfter() != null) {
				int after = Integer.parseInt(rsm.getAfter());
				// it is ok, if we go out of range we will return empty result
				index = after + 1;
			} else if (rsm.getBefore() != null) {
				int before = Integer.parseInt(rsm.getBefore());
				index = before - rsm.getMax();
			// if we go out of range we need to set index to 0 and reduce limit
				// to return proper results
				if (index < 0) {
					index = 0;
					limit = before;
				}
			} else if (rsm.hasBefore()) {
				index = count - rsm.getMax();
				if (index < 0) {
					index = 0;
				}
			}

			List<Element> items = getItems(owner, jids_ids[0], jids_ids[1], startTimestamp,
					endTimestamp, index, limit);

			rsm.setResults(count, index);
			if (!items.isEmpty()) {
				rsm.setFirst(String.valueOf(index));
				rsm.setLast(String.valueOf(index + (items.size() - 1)));
			}

			return items;
		} catch (SQLException ex) {
			throw new TigaseDBException("Cound not retrieve items", ex);
		}		
	}

	//~--- methods --------------------------------------------------------------

	/**
	 * Method description
	 *
	 *
	 * @param owner
	 * @param withJid
	 * @param start
	 * @param end
	 *
	 * @throws TigaseDBException
	 */
	@Override
	public void removeItems(BareJID owner, String withJid, Date start, Date end)
					throws TigaseDBException {
		try {
			long[] jids_ids = getJidsIds(owner.toString(), withJid);

			if (start == null) {
				start = new Date(0);
			}
			if (end == null) {
				end = new Date(0);
			}

			java.sql.Timestamp start_ = new java.sql.Timestamp(start.getTime());
			java.sql.Timestamp end_ = new java.sql.Timestamp(end.getTime());
			PreparedStatement remove_msgs_st = data_repo.getPreparedStatement(owner, REMOVE_MSGS);

			synchronized (remove_msgs_st) {
				synchronized (remove_msgs_st) {
					remove_msgs_st.setLong(1, jids_ids[0]);
					remove_msgs_st.setLong(2, jids_ids[1]);
					remove_msgs_st.setTimestamp(3, end_);
					remove_msgs_st.setTimestamp(4, start_);
					remove_msgs_st.executeUpdate();
				}
			}
		} catch (SQLException ex) {
			throw new TigaseDBException("Cound not remove items", ex);
		}
	}

	private List<Element> getCollections(BareJID owner,long ownerId, Long buddyId, Timestamp start,
					Timestamp end, int index, int limit, String queryStr)
					throws SQLException {
		List<Element> results = new LinkedList<Element>();
		ResultSet selectRs   = null;
		try {
			PreparedStatement get_collections_st = data_repo.getPreparedStatement(owner, "GET_COLLECTIONS_" 
					+ queryStr + "_SELECT");

			int i=2;
			synchronized (get_collections_st) {
				get_collections_st.setLong(1, ownerId);
				if (start != null) {
					get_collections_st.setTimestamp(i++, start);
				}
				if (end != null) {
					get_collections_st.setTimestamp(i++, end);
				}
				if (buddyId != null) {
					get_collections_st.setLong(i++, buddyId);
				}
				
				switch (data_repo.getDatabaseType()) {
					case derby:
						get_collections_st.setInt(i++, index);						
						get_collections_st.setInt(i++, limit);
						break;
					case sqlserver:
						get_collections_st.setInt(i++, index);
						get_collections_st.setInt(i++, index + limit);
						break;
					default:
						get_collections_st.setInt(i++, limit);
						get_collections_st.setInt(i++, index);
						break;
				}
				selectRs = get_collections_st.executeQuery();
				while (selectRs.next()) {
					Timestamp startTs = selectRs.getTimestamp(1);
					String with = selectRs.getString(2);
					addCollectionToResults(results, with, startTs);
				}
			}
		} finally {
			data_repo.release(null, selectRs);
		}
		return results;
	}	
	
	private Integer getCollectionsCount(BareJID owner, long ownerId, Long buddyId, Timestamp start_, 
			Timestamp end_, String queryStr) throws SQLException {
		ResultSet countRs = null;		
		Integer count = null;
		try {
			PreparedStatement get_collections_count = data_repo.getPreparedStatement(owner, "GET_COLLECTIONS_" 
					+ queryStr + "_COUNT");
			int i=2;
			synchronized (get_collections_count) {
				get_collections_count.setLong(1, ownerId);
				if (start_ != null) {
					get_collections_count.setTimestamp(i++, start_);
				}
				if (end_ != null) {
					get_collections_count.setTimestamp(i++, end_);
				}
				if (buddyId != null) {
					get_collections_count.setLong(i++, buddyId);
				}				
				countRs = get_collections_count.executeQuery();
				if (countRs.next()) {
					count = countRs.getInt(1);
				}
			}
		} finally {
			data_repo.release(null, countRs);
		}
		return count;
	}
	
	private List<Element> getItems(BareJID owner, long ownerId, long withId, Timestamp startTimestamp, 
			Timestamp endTimestamp, int offset, int limit) throws SQLException {
		ResultSet rs      = null;		
		Queue<Item> results = new ArrayDeque<Item>();
		int i=1;
		try {
			PreparedStatement get_messages_st = data_repo.getPreparedStatement(owner, endTimestamp != null 
					? GENERIC_GET_MESSAGES_END : GENERIC_GET_MESSAGES);
			synchronized (get_messages_st) {
				get_messages_st.setLong(i++, ownerId);
				get_messages_st.setLong(i++, withId);
				get_messages_st.setTimestamp(i++, startTimestamp);

				if (endTimestamp != null) {
					get_messages_st.setTimestamp(i++, endTimestamp);
				}
				switch (data_repo.getDatabaseType()) {
					case derby:
						get_messages_st.setInt(i++, offset);
						get_messages_st.setInt(i++, limit);
						break;
					case sqlserver:
						get_messages_st.setInt(i++, offset);
						get_messages_st.setInt(i++, offset+limit);
						break;
					default:
						get_messages_st.setInt(i++, limit);
						get_messages_st.setInt(i++, offset);
						break;
				}

				rs = get_messages_st.executeQuery();
				while (rs.next()) {
					Item item = new Item();
					item.message = rs.getString(1);
					item.timestamp = rs.getTimestamp(2);
					item.direction = Direction.getDirection(rs.getShort(3));
					results.offer(item);
				}
			}
		} finally {
			data_repo.release(null, rs);
		}

		List<Element> msgs = null;

		if (!results.isEmpty()) {
			msgs = new LinkedList<Element>();

			DomBuilderHandler domHandler = new DomBuilderHandler();

			Item item = null;
			while ((item = results.poll()) != null) {
				parser.parse(domHandler, item.message.toCharArray(), 0, item.message.length());

				Queue<Element> queue = domHandler.getParsedElements();
				Element msg = null;

				while ((msg = queue.poll()) != null) {
					addMessageToResults(msgs, startTimestamp, msg, item.timestamp, item.direction);
				}			
			}

			// no point in sorting messages by secs attribute as messages are already
			// sorted in SQL query and also this sorting is incorrect
//			Collections.sort(msgs, new Comparator<Element>() {
//				@Override
//				public int compare(Element m1, Element m2) {
//					return m1.getAttributeStaticStr("secs").compareTo(
//							m2.getAttributeStaticStr("secs"));
//				}
//			});
		}

		return msgs;		
	}

	private Integer getItemsCount(BareJID owner, long ownerId, long withId, Timestamp startTimestamp, 
			Timestamp endTimestamp) throws SQLException {
		ResultSet rs      = null;		
		Integer count = null;
		int i=1;
		try {
			PreparedStatement get_messages_st = data_repo.getPreparedStatement(owner, endTimestamp != null 
					? GENERIC_GET_MESSAGES_END_COUNT : GENERIC_GET_MESSAGES_COUNT);
			synchronized (get_messages_st) {
				get_messages_st.setLong(i++, ownerId);
				get_messages_st.setLong(i++, withId);
				get_messages_st.setTimestamp(i++, startTimestamp);

				if (endTimestamp != null) {
					get_messages_st.setTimestamp(i++, endTimestamp);
				}

				rs = get_messages_st.executeQuery();
				if (rs.next()) {
					count = rs.getInt(1);
				}
			}
		} finally {
			data_repo.release(null, rs);
		}
		return count;
	}
	
	/**
	 * Method description
	 *
	 *
	 * @param jids
	 *
	 * @return
	 *
	 * @throws SQLException
	 */
	protected long[] getJidsIds(String... jids) throws SQLException {
		ResultSet rs = null;

		try {
			long[] results = new long[jids.length];

			Arrays.fill(results, LONG_NULL);
			if (jids.length == 1) {
				PreparedStatement get_jid_id_st = data_repo.getPreparedStatement(null,
																						GET_JID_ID_QUERY);

				synchronized (get_jid_id_st) {
					get_jid_id_st.setString(1, jids[0]);
					rs = get_jid_id_st.executeQuery();
					if (rs.next()) {
						results[0] = rs.getLong("jid_id");

						return results;
					}
				}

				return results;
			} else {
				PreparedStatement get_jids_id_st = data_repo.getPreparedStatement(null,
																						 GET_JID_IDS_QUERY);

				synchronized (get_jids_id_st) {
					for (int i = 0; i < jids.length; i++) {
						get_jids_id_st.setString(i + 1, jids[i]);
					}
					rs = get_jids_id_st.executeQuery();

					int cnt = 0;

					while (rs.next()) {
						String db_jid = rs.getString("jid");

						for (int i = 0; i < jids.length; i++) {
							if (db_jid.equals(jids[i])) {
								results[i] = rs.getLong("jid_id");
								++cnt;
							}
						}
					}

					return results;
				}
			}
		} finally {
			data_repo.release(null, rs);
		}
	}

	//~--- methods --------------------------------------------------------------

	private long addJidId(String jid) throws SQLException {
		PreparedStatement add_jid_st = data_repo.getPreparedStatement(null, ADD_JID_QUERY);

		synchronized (add_jid_st) {
			add_jid_st.setString(1, jid);
			add_jid_st.executeUpdate();
		}

		// This is not the most effective solution but this method shouldn't be
		// called very often so the perfrmance impact should be insignificant.
		long[] jid_ids = getJidsIds(jid);

		if (jid_ids != null) {
			return jid_ids[0];
		} else {

			// That should never happen here, but just in case....
			log.log(Level.WARNING, "I have just added new jid but it was not found.... {0}",
							jid);

			return LONG_NULL;
		}
	}
	
	private class Item {
		
		String message;
		Date timestamp;
		Direction direction;
		
	}
}


//~ Formatted in Tigase Code Convention on 13/02/20
